## 题目描述

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。

示例 1:
```
给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
```
示例 2:
```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```
来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 我的开始思路

因为是有序数组，所以遍历找不同就行，把找到的不同赋值给记录的位置，最后返回记录位置+1即可

## 代码

- 语言支持：C#

```C#
        public int RemoveDuplicates(int[] nums)
        {
            if (nums.Length <= 1) return nums.Length;

            int cur = 0;
            int len = nums.Length;

            for (int i = 1; i < len; i++)
            {
                if (nums[i] != nums[cur])
                {
                    nums[++cur] = nums[i];
                }
            }

            return cur + 1;
        }
```

## 所学、所悟

提交后发现用时比较慢，但时间复杂度已经是O(N)了，于是看了下最快的，发现思路是完全一样的，甚至代码也很像

CV提交后，发现果然很快，于是仔细核对后，发现唯一不一样的地方竟然还for循环中的i++和++i

把自己代码中的i++改为++i后，果然变快了

百度后，悟了，确实i++肯定需要一个临时变量来记录，所以导致会慢一点，那么问题又来了，为什么自动生成的for循环语句使用i++呢

故又百度之，找到比较靠谱的解释是因为大部分情况下，造成的性能差异很小，可能是i++使用惯了，比较好看

当然，在某些领域，比如嵌入式，还是应该注意的

知乎上看到一个评论：优化代码交给编！译！器！

感觉很有道理，但是身为程序员，也应该知道这种细节
